CPC 보고와 비슷하게 엑셀 파일에 필요한 데이터를 자동으로 삽입하고 다운로드하는 기능

# 엑셀 양식
![[Pasted image 20250218175033.png]]

# 엑셀에 넣어야하는 데이터
1. 연체잔액 증감표 및 연체잔액 예상표에 주단위 데이터 생성 및 삽입
     ex)24.12.27이 기준일이면 11.30 ~ 12.06, 12.7~12.13, 12.14~12.20, 12.21~12.27
2. 해당 날짜를 기준으로 데이터 추출
3.  연체잔액 예상표는 월단위로 데이터를 추출하지만 조회 기준일 기준 3개월 전의 확정 데이터와 향후 6개월의 예상 데이터를 추출해야함
4.  연체해결 상세내역 및 신규연체 상세내역에는 조회 기준일 현재월의 초일 ~ 조회기준일 까지의 데이터를 추출

**위의 데이터를 DB에서 추출하여 엑셀에 삽입 후 다운로드하면 해당 기능 개발은 끝


# ToDo 리스트
1.  엑셀 양식 DB에 저장
2.  쿼리 작성
3.  프론트 페이지 작성
4.  백엔드 로직 작성
5.  테스트


# 엑셀 양식 DB에 저장
엑셀 양식은 Postgersql 기준 bytea 타입으로 저장
![[Pasted image 20250218181001.png]]

# 쿼리 작성
현 기능 개발의 가장 큰 비중을 차지하는 쿼리 작성이다.
최초에는 한 쿼리에 끝내고 싶었지만 여러 개로 나눠서 작성했다.
이유는 테이블 간 데이터 정합성이 맞지 않는 경우가 있었고
데이터를 추출하는 기간의 기준이 다른 경우(주별, 월별) , 해당 엑셀에 들어가는 데이터를 구하는 쿼리가 매우 복잡해서
추후 유지보수 용이성을 고려하여 쿼리를 나누었다.

**주요 사용 테이블**
stats_loan_balance : 대출 회원별 대출 금액, 연체 상태, 연체일 등을 일일 단위로 저장한
                    로그성 테이블
repayment_state_history : 상환상태 변경 내역 테이블(연체가 시작되거나 끝났을 때 기록)
resolved_overdue_loan : 연체채권 상환 내역 테이블(연체된 채권 상환 시 기록)

1. **연체잔액 증감표 및 연체잔액 예상표**
     최초에는 해당 부분을 한 쿼리로 끝내려고 했지만 join 과정과 기간 산정에서 문제 발생
     
     시작, 마감 / 신규, 해소 / 전체 대출 총 세 부분으로 나눠서 쿼리를 작성했다.
     
     join 문제 : 시작, 마감은 repayment_state_history 테이블과 inner join을 해야 원하는 결과값이 나오지만 신규, 해소는 해당 테이블이 필요없다.
     repayment_state_history를 inner join 하는 순간 신규, 해소에서 필요한 데이터가
     없어져서 한 쿼리에서 구할 방법이 없어서 쿼리를 나누었다.
     
     기간 산정 문제 : 시작, 마감 / 신규, 해소는 4주치만 조회하면 되지만 전체 대출은
     5주치를 조회하여 누적합을 구해야한다.
     쿼리의 가독성과 백엔드 로직 작성 시 혼동을 줄이기 위해 쿼리를 나누었다.
     
     **시작, 마감 쿼리**
     with settle as (
		SELECT
		loan_uid,
		sum(settlement_amount) as settlement_amount,
		MAX(reg_datetime::date) AS reg_datetime
		from resolved_overdue_loan
		where reg_datetime between '2024-11-23' AND '2024-12-20'::date + INTERVAL '1 day'
		GROUP BY
		loan_uid
		ORDER BY
		loan_uid
		)
		SELECT
		CASE
		WHEN slb.base_date between '2024-11-23' and '2024-11-29' THEN '11.23~11.29'
		WHEN slb.base_date between '2024-11-30' and '2024-12-06' THEN '11.30~12.06'
		WHEN slb.base_date between '2024-12-07' and '2024-12-13' THEN '12.07~12.13'
		WHEN slb.base_date between '2024-12-14' and '2024-12-20' THEN '12.14~12.20'
		ELSE '기타'
		END AS date_range,
		floor(SUM(
		CASE
		WHEN slb.base_date IN ('2024-11-23', '2024-11-30', '2024-12-07', '2024-12-14')
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		ELSE 0
		end)/1000
		) AS start_week,
		floor(SUM(
		CASE
		WHEN slb.base_date IN ('2024-11-29', '2024-12-06', '2024-12-13', '2024-12-20')
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		ELSE 0
		end)/1000
		) AS end_Week
		FROM
		stats_loan_balance slb
		inner join repayment_state_history rsh
		on slb.loan_uid = rsh.loan_uid
		and RSH.seq = ( SELECT MAX(seq)
		FROM REPAYMENT_STATE_HISTORY
		WHERE loan_uid = slb.loan_uid )
		left join settle s
		on slb.loan_uid = s.loan_uid
		WHERE
		slb.base_date BETWEEN '2024-11-23' AND '2024-12-20'
		GROUP BY
		date_range
		ORDER BY
		date_range;
		
	**신규, 해소 쿼리**
		with latest_base_date AS (
		SELECT
		loan_uid,
		MAX(CASE WHEN base_date BETWEEN '2024-12-21' AND '2024-12-27' THEN base_date END) AS max_date_1,
		MAX(CASE WHEN base_date BETWEEN '2024-12-28' AND '2025-01-03' THEN base_date END) AS max_date_2,
		MAX(CASE WHEN base_date BETWEEN '2025-01-04' AND '2025-01-10' THEN base_date END) AS max_date_3,
		MAX(CASE WHEN base_date BETWEEN '2025-01-11' AND '2025-01-17' THEN base_date END) AS max_date_4
		FROM stats_loan_balance
		WHERE base_date BETWEEN '2024-12-21' AND '2025-01-17'
		GROUP BY loan_uid
		),
		settle as (
		SELECT
		loan_uid,
		settlement_amount,
		MAX(reg_datetime::date) AS reg_datetime
		from resolved_overdue_loan
		where reg_datetime between '2024-12-21' AND '2025-01-17'::date + INTERVAL '1 day'
		GROUP BY
		loan_uid, settlement_amount
		ORDER BY
		loan_uid
		),
		first_date as(
		SELECT loan_uid, MIN(base_date) AS first_base_date
		FROM (
		SELECT
		slb.loan_uid,
		slb.base_date,
		slb.overdue_date,
		LAG(slb.overdue_date) OVER (PARTITION BY slb.loan_uid ORDER BY slb.base_date) AS prev_overdue_date
		FROM stats_loan_balance slb
		where slb.base_date between '2024-12-21' and '2025-01-17'
		) sub
		WHERE prev_overdue_date IS NULL
		AND overdue_date IS NOT null
		GROUP BY loan_uid
		)
		SELECT
		CASE
		WHEN slb.base_date between '2024-12-21' AND '2024-12-27' THEN '2024-12-21 ~ 2024-12-27'
		WHEN slb.base_date between '2024-12-28' AND '2025-01-03' THEN '2024-12-28 ~ 2025-01-03'
		WHEN slb.base_date between '2025-01-04' AND '2025-01-10' THEN '2025-01-04 ~ 2025-01-10'
		WHEN slb.base_date between '2025-01-11' AND '2025-01-17' THEN '2025-01-11 ~ 2025-01-17'
		ELSE '기타'
		END AS date_range,
		floor(SUM(
		CASE
		WHEN slb.base_date = fd.first_base_date
		AND slb.overdue_date BETWEEN'2024-12-21' AND '2024-12-27'::date
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		WHEN slb.base_date = fd.first_base_date
		AND slb.overdue_date BETWEEN '2024-12-28' AND '2025-01-03'::date
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		WHEN slb.base_date = fd.first_base_date
		AND slb.overdue_date BETWEEN '2025-01-04' AND '2025-01-10'::date
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		WHEN slb.base_date = fd.first_base_date
		AND slb.overdue_date BETWEEN '2025-01-11' AND '2025-01-17'::date
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		THEN slb.balance_amount
		ELSE 0
		end)/1000
		) AS new_Overdue_Week,
		floor(sum(
		case
		when slb.base_date = lbd.max_date_1
		and s.reg_datetime::date between '2024-12-21' AND '2024-12-27' then s.settlement_amount
		when slb.base_date = lbd.max_date_2
		and s.reg_datetime::date between '2024-12-28' AND '2025-01-03' then s.settlement_amount
		when slb.base_date = lbd.max_date_3
		and s.reg_datetime::date between '2025-01-04' AND '2025-01-10' then s.settlement_amount
		when slb.base_date = lbd.max_date_4
		and s.reg_datetime::date between '2025-01-11' AND '2025-01-17' then s.settlement_amount
		else 0
		end)/1000
		)as out_Overdue_Week
		FROM
		stats_loan_balance slb
		left join latest_base_date lbd
		on slb.loan_uid = lbd.loan_uid
		left join settle s
		on slb.loan_uid = s.loan_uid
		left join first_date fd
		on slb.loan_uid = fd.loan_uid
		WHERE
		slb.base_date BETWEEN '2024-12-21' AND '2025-01-17'
		GROUP BY
		date_range
		ORDER BY
		date_range;
		
	**전체 대출 부분 쿼리**
		with calc as (
		select
		CASE
		when slb.base_date between '2024-11-16' and '2024-11-22' THEN '11.16~11.22'
		WHEN slb.base_date between '2024-11-23' and '2024-11-29' THEN '11.23~11.29'
		WHEN slb.base_date between '2024-11-30' and '2024-12-06' THEN '11.30~12.06'
		WHEN slb.base_date between '2024-12-07' and '2024-12-13' THEN '12.07~12.13'
		WHEN slb.base_date between '2024-12-14' and '2024-12-20' THEN '12.14~12.20'
		ELSE '기타'
		END AS date_range,
		count(
		case
		when slb.base_date in('2024-11-22', '2024-11-29', '2024-12-06', '2024-12-13', '2024-12-20')
		then slb.uid
		end
		) as account,
		floor(sum(case
		when slb.base_date in('2024-11-22', '2024-11-29', '2024-12-06', '2024-12-13', '2024-12-20')
		then slb.balance_amount end)/1000) as balance_amount
		from stats_loan_balance slb
		where slb.base_date between '2024-11-16' and '2024-12-20'
		and slb.loan_state = 'REPAYING'
		group by date_range
		order by date_range)
		select
		date_range,
		account as account_count,
		account - lag(account, 1, 0) over(order by date_range) as account_count_variation,
		balance_amount as balance,
		balance_amount - lag(balance_amount, 1, 0) over(order by date_range) as balance_variation
		from calc;

	**2. 연체 잔액 예상표**
		월시작, 장기연체 / 연체 해결 합계, 매각 상환 / 신규발생 연체 / 배당 상환 4가지로 쿼리를 나누었다.
		쿼리를 나눈 이유는 가독성과 유지보수 용이성이지만 배당 상환은 주요 테이블과 다른 테이블을 주로 사용하여
		나누어서 작성했다.
		
	**월 시작, 장기연체 쿼리**
		SELECT
		CASE
		WHEN slb.base_date BETWEEN '2024-10-01' AND '2024-10-31' THEN 'first'
		WHEN slb.base_date BETWEEN '2024-11-01' AND '2024-11-30' THEN 'second'
		WHEN slb.base_date BETWEEN '2024-12-01' AND '2024-12-31' THEN 'third'
		WHEN slb.base_date BETWEEN '2025-01-01' AND '2025-01-31' THEN 'urth'
		ELSE '기타'
		END AS date_range,
		FLOOR(SUM(CASE
		WHEN slb.base_date IN ('2024-10-01', '2024-11-01', '2024-12-01', '2025-01-01') THEN slb.balance_amount
		END) / 1000) AS start_month,
		FLOOR(SUM(CASE
		WHEN slb.base_date IN ('2024-10-31', '2024-11-30', '2024-12-31', '2025-01-03')
		AND slb.loan_uid IN (8987, 10067, 12113, 13906) THEN slb.balance_amount
		END) / 1000) AS long_overdue
		FROM stats_loan_balance slb
		WHERE slb.base_date BETWEEN '2024-10-01' AND '2025-01-31'
		AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')
		GROUP BY date_range
		ORDER BY date_range;
	
	**연체 해결 합계, 매각 상환 쿼리**
	with latest_base_date AS (
		SELECT
		loan_uid,
		MAX(CASE WHEN base_date BETWEEN '2024-10-01' AND '2024-10-31' THEN base_date END) AS max_date_1,
		MAX(CASE WHEN base_date BETWEEN '2024-11-01' AND '2024-11-30' THEN base_date END) AS max_date_2,
		MAX(CASE WHEN base_date BETWEEN '2024-12-01' AND '2024-12-31' THEN base_date END) AS max_date_3,
		MAX(CASE WHEN base_date BETWEEN '2025-01-01' AND '2025-01-31' THEN base_date END) AS max_date_4
		FROM stats_loan_balance
		WHERE base_date BETWEEN '2024-10-01' AND '2025-01-31'
		GROUP BY loan_uid
		),
		settle as (
		SELECT
		loan_uid,
		TO_CHAR(reg_datetime, 'YYYY-MM') AS year_month,
		settlement_amount,
		MAX(reg_datetime::date) AS reg_datetime
		FROM
		resolved_overdue_loan
		WHERE
		reg_datetime BETWEEN '2024-10-01' AND '2025-01-31'::date + INTERVAL '1 day'
		GROUP BY
		loan_uid,
		TO_CHAR(reg_datetime, 'YYYY-MM'),
		settlement_amount
		ORDER BY
		loan_uid,
		year_month
		), sale as(
		select loan_uid, current_loan_amount, sale_end_date
		from loan_sale_list
		where sale_end_date between '2024-10-01' and '2025-01-31'
		)
		SELECT
		CASE
		WHEN slb.base_date between '2024-10-01' and '2024-10-31' THEN 'first'
		WHEN slb.base_date between '2024-11-01' and '2024-11-30' THEN 'second'
		WHEN slb.base_date between '2024-12-01' and '2024-12-31' THEN 'third'
		WHEN slb.base_date BETWEEN '2025-01-01' AND '2025-01-31' THEN 'urth'
		ELSE '기타'
		END AS date_range,
		floor(sum(
		case
		when slb.base_date = lbd.max_date_1
		and sl.reg_datetime::date between '2024-10-01' AND '2024-10-31'
		and slb.loan_uid not in (8987, 10067, 12113, 13906) then sl.settlement_amount
		when slb.base_date = lbd.max_date_2
		and sl.reg_datetime::date between '2024-11-01' AND '2024-11-30'
		and slb.loan_uid not in (8987, 10067, 12113, 13906) then sl.settlement_amount
		when slb.base_date = lbd.max_date_3
		and sl.reg_datetime::date between '2024-12-01' AND '2024-12-31'
		and slb.loan_uid not in (8987, 10067, 12113, 13906) then sl.settlement_amount
		when slb.base_date = lbd.max_date_4
		and sl.reg_datetime::date between '2025-01-01' AND '2025-01-31'
		and slb.loan_uid not in (8987, 10067, 12113, 13906) then sl.settlement_amount
		else 0
		end)/1000
		)as out_overdue_month,
		floor(sum(
		case
		WHEN slb.base_date = lbd.max_date_1 and s.sale_end_date between '2024-10-01' and '2024-10-31' THEN s.current_loan_amount
		WHEN slb.base_date = lbd.max_date_2 and s.sale_end_date between '2024-11-01' and '2024-11-30' THEN s.current_loan_amount		
		WHEN slb.base_date = lbd.max_date_3 and s.sale_end_date between '2024-12-01' and '2024-12-31' THEN s.current_loan_amount
		WHEN slb.base_date = lbd.max_date_4 and s.sale_end_date between '2025-01-01' and '2025-01-31' THEN s.current_loan_amount
		else 0
		end)/1000
		) as sale_repayment,
		FLOOR(SUM(case
		when slb.base_date = lbd.max_date_1
		AND slb.loan_uid IN (8987, 10067, 12113, 13906) and sl.reg_datetime::date between '2024-10-01' AND '2024-10-31' then sl.settlement_amount
		when slb.base_date = lbd.max_date_2
		AND slb.loan_uid IN (8987, 10067, 12113, 13906) and sl.reg_datetime::date between '2024-11-01' AND '2024-11-30' then sl.settlement_amount
		when slb.base_date = lbd.max_date_3
		AND slb.loan_uid IN (8987, 10067, 12113, 13906) and sl.reg_datetime::date between '2024-12-01' AND '2024-12-31' then sl.settlement_amount
		when slb.base_date = lbd.max_date_4
		AND slb.loan_uid IN (8987, 10067, 12113, 13906) and sl.reg_datetime::date between '2025-01-01' AND '2025-01-31' then sl.settlement_amount
		else 0
		END) / 1000) AS long_overdue_repayment,
		count(
		case
		when slb.base_date = '2025-01-03' and s.sale_end_date between '2025-01-01' and '2025-01-03' then s.current_loan_amount
		end
		) as out_sale_repayment_count,
		floor(COALESCE(SUM(
		CASE
		WHEN slb.base_date = '2025-01-03'
		AND s.sale_end_date BETWEEN '2025-01-01' AND '2025-01-03'
		THEN s.current_loan_amount
		END
		), 0)/1000) AS out_sale_repayment_sum,
		count(
		case
		when slb.base_date = '2025-01-03' and s.sale_end_date between '2025-01-04' and '2025-01-31' then s.current_loan_amount
		end
		) as out_sale_repayment_count_expectation,
		floor(coalesce(sum(
		case
		when slb.base_date = '2025-01-03' and s.sale_end_date between '2025-01-04' and '2025-01-31' then s.current_loan_amount
		end
		), 0)/1000) as out_sale_repayment_sum_expectation
		from stats_loan_balance slb
		inner join repayment_state_history rsh
		on slb.loan_uid = rsh.loan_uid
		and RSH.seq = ( SELECT MAX(seq)
		FROM REPAYMENT_STATE_HISTORY
		WHERE loan_uid = slb.loan_uid )
		left join latest_base_date lbd
		on slb.loan_uid = lbd.loan_uid
		left join settle sl
		on slb.loan_uid = sl.loan_uid
		left join sale s
		on slb.loan_uid = s.loan_uid
		WHERE
		slb.base_date BETWEEN '2024-10-01' AND '2025-01-31'
		GROUP BY
		date_range
		ORDER BY
		date_range;
	
	**신규발생 연체 쿼리**
	WITH repay AS (
		SELECT
		loan_uid,
		overdue_date,
		repayment_state,
		row_number() over(partition by loan_uid, overdue_date order by overdue_date) as rn
		FROM repayment_state_history
		WHERE overdue_date BETWEEN '2024-10-01' AND '2025-01-03'
		group by loan_uid, overdue_date, repayment_state
		order by loan_uid, overdue_date
		),
		filtered_loans AS (
		SELECT
		slb.loan_uid,
		slb.balance_amount,
		DATE_TRUNC('month', re.overdue_date) AS month,
		re.repayment_state
		FROM stats_loan_balance slb
		INNER JOIN repay re
		ON slb.loan_uid = re.loan_uid
		WHERE slb.base_date = re.overdue_date
		and slb.base_date between '2024-10-01' and '2025-01-03'
		and re.rn = 1
		group by slb.loan_uid, slb.balance_amount, month, re.repayment_state)
		SELECT
		TO_CHAR(month, 'YYYY-MM') AS month,
		floor(sum(balance_amount)/1000) as total_new_overdue,
		floor(SUM(case
		when repayment_state = 'PRINCIPAL_DELAY' then balance_amount end)/1000) AS principal_loan_amount,
		floor(SUM(case
		when repayment_state = 'INTEREST_DELAY' then balance_amount end)/1000) AS interest_loan_amount
		FROM filtered_loans
		where repayment_state = 'PRINCIPAL_DELAY' or repayment_state = 'INTEREST_DELAY'
		GROUP BY month
		ORDER BY month;
	
	**배당 상환 쿼리**
	with manager as(
		select *
		from court_auction_manager
		where end_result = '배당종결' and end_result_datetime between '2024-10-01' and '2024-12-31'
		),
		manager_non_finish as(
		select *
		from court_auction_manager
		where end_result = '미종국'
		),
		detail as(
		select *
		from court_auction_detail
		where type = '배당기일' and fixed_datetime between '2024-10-01' and '2024-12-31'
		),
		add_detail as(
		select *
		from manager_non_finish mnf
		inner join detail d
		on mnf.uid = d.court_auction_manager_uid
		), result as(
		select COALESCE(m.loan_list, ad.loan_list) AS loan_list, m.end_result_datetime::date, ad.fixed_datetime::date
		from manager m
		full outer join add_detail ad
		on m.uid = ad.court_auction_manager_uid
		), loan_uid_result as(
		select distinct on(l.loan_uid) l.loan_uid, l.loan_no, coalesce(r.end_result_datetime, r.fixed_datetime) as result_date
		from loan l
		inner join result r
		on l.loan_uid = any(r.loan_list)
		),sale as(
		select loan_uid, current_loan_amount, sale_end_date
		from loan_sale_list
		where sale_end_date between '2025-01-01' and '2025-01-31'
		)
		select
		CASE
		WHEN lur.result_date BETWEEN '2024-10-01' AND '2024-10-31' THEN 'first'
		WHEN lur.result_date BETWEEN '2024-11-01' AND '2024-11-30' THEN 'second'
		WHEN lur.result_date BETWEEN '2024-12-01' AND '2024-12-31' THEN 'third'
		ELSE '기타'
		END AS date_range,
		floor(sum(
		case
		when lur.result_date between '2024-10-01' and '2024-10-31' then rol.settlement_amount
		when lur.result_date between '2024-11-01' and '2024-11-30' then rol.settlement_amount
		when lur.result_date between '2024-12-01' and '2024-12-31' then rol.settlement_amount
		end)/1000
		) as distribution,
		count(
		case
		when lur.result_date between '2025-01-01' and '2025-01-03' then rol.settlement_amount
		end
		) as out_distribution_count,
		sum(
		case
		when lur.result_date between '2025-01-01' and '2025-01-03' then rol.settlement_amount
		end
		) as out_distribution_sum
		from loan_uid_result lur
		left join resolved_overdue_loan rol
		on lur.loan_uid = rol.loan_uid and rol.reg_datetime::date between '2024-10-01' and '2024-12-31'
		left join sale s
		on lur.loan_uid = s.loan_uid
		group by date_range
		order by date_range;

**3. 연체해결 상세내역 및 신규연체 상세내역**
	자력해결 완료 / 신규 연체 발생 종류별 쿼리로 나누었다.
	배당, 매각은 2. 연체 잔액 예상표 쿼리에서 같이 데이터를 추출해 해당 부분에서 따로 추출할 필요는 없다.

**자력해결 완료 쿼리**
	with manager as(
		select *
		from court_auction_manager
		where end_result = '배당종결' and end_result_datetime between '2024-10-01' and '2025-01-31'
		),
		manager_non_finish as(
		select *
		from court_auction_manager
		where end_result = '미종국'
		),
		detail as(
		select *
		from court_auction_detail
		where type = '배당기일' and fixed_datetime between '2024-10-01' and '2025-01-31'
		),
		add_detail as(
		select *
		from manager_non_finish mnf
		inner join detail d
		on mnf.uid = d.court_auction_manager_uid
		), result as(
		select COALESCE(m.loan_list, ad.loan_list) AS loan_list, m.end_result_datetime::date, ad.fixed_datetime::date
		from manager m
		full outer join add_detail ad
		on m.uid = ad.court_auction_manager_uid
		), loan_uid_result as(
		select distinct on(l.loan_uid) l.loan_uid, l.loan_no, coalesce(r.end_result_datetime, r.fixed_datetime) as result_date
		from loan l
		inner join result r
		on l.loan_uid = any(r.loan_list)
		),sale as(
		select loan_uid, current_loan_amount, sale_end_date
		from loan_sale_list
		where sale_end_date between '2025-01-01' and '2025-01-31'
		), rol_result as(
		select distinct on(loan_uid) *
		from resolved_overdue_loan rol
		where reg_datetime::date between '2025-01-01' and '2025-01-20'
		)
		select
		count(case
		when rr.reg_datetime::date between '2025-01-01' and '2025-01-20' and lur.loan_uid is null then rr.settlement_amount
		end
		) as self_repayment_count,
		floor(sum(
		case
		when rr.reg_datetime::date between '2025-01-01' and '2025-01-20' and lur.loan_uid is null then rr.settlement_amount
		end)/1000
		) as self_repayment_sum
		from rol_result rr
		left join loan_uid_result lur
		on rr.loan_uid = lur.loan_uid
		left join sale s
		on rr.loan_uid = s.loan_uid
		where rr.reg_datetime::date between '2025-01-01' and '2025-01-31';
	
**신규 연체발생 종류별 쿼리**
	WITH repay AS (
		SELECT DISTINCT ON (loan_uid)
		loan_uid,
		repayment_state,
		overdue_date
		FROM repayment_state_history
		WHERE overdue_date BETWEEN '2025-02-01'::date AND '2025-02-02'::date
		order by loan_uid, overdue_date
		),
		filtered_loans as(SELECT DISTINCT ON (slb.loan_uid)
		slb.loan_uid,
		slb.balance_amount,
		DATE_TRUNC('month', re.overdue_date) AS month,
		re.repayment_state
		FROM stats_loan_balance slb
		INNER JOIN repay re
		ON slb.loan_uid = re.loan_uid
		WHERE slb.base_date between '2025-02-01'::date AND '2025-02-02'::date)
		SELECT
		TO_CHAR(month, 'YYYY-MM') AS month,		
		count(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'NORMAL' then balance_amount end)
		as principal_normal_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'NORMAL' then balance_amount end), 0)/1000
		) as principal_normal_sum,
		count(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'NORMAL' then balance_amount end)
		as interest_normal_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'NORMAL' then balance_amount end), 0)/1000
		) as interest_normal_sum,
		count(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'ADD' then balance_amount end)
		as principal_add_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'ADD' then balance_amount end), 0)/1000
		) as principal_add_sum,
		count(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'ADD' then balance_amount end)
		as interest_add_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'ADD' then balance_amount end), 0)/1000
		) as interest_add_sum,
		count(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'EXTEND' then balance_amount end)
		as principal_extend_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'PRINCIPAL_DELAY' and l.relation_loan_kind = 'EXTEND' then balance_amount end), 0)/1000
		) as principal_extend_sum,
		count(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'EXTEND' then balance_amount end)
		as interest_extend_count,
		floor(coalesce(sum(case
		when fl.repayment_state = 'INTEREST_DELAY' and l.relation_loan_kind = 'EXTEND' then balance_amount end), 0)/1000
		) as interest_extend_sum
		FROM filtered_loans fl
		left join loan l
		on fl.loan_uid = l.loan_uid
		where fl.repayment_state = 'PRINCIPAL_DELAY' or fl.repayment_state = 'INTEREST_DELAY'
		GROUP BY month
		ORDER BY month;

# 프론트 페이지 작성

프론트 페이지는 CPC 자동화 페이지와 동일하게 조회 기준일자를 입력하고 form 전송해주는 간단한 페이지이다.
기존 CPC 자동화 페이지를 활용하여 만들어서 딱히 건드릴게 없었다.
title 수정, html id, name 수정 정도가 끝이었지만
개발 중 추가 요구사항으로 JavaScript 함수 추가

**추가 요구 사항**
![[Pasted image 20250219110711.png]]
최초에는 일자 계산 부분만 있었지만 아래에 주차별 일자를 확인하고 사용자가 변경할 수 있도록 기능이 변경되었다.
그리고 조회 기준일의 해당 주차가 전월의 말일이 포함되면 말일을 기준으로 잘라서 한 줄 추가되도록 요구사항이 변경되었다.
ex) 2025-02-02가 조회 기준일이면 2025-01-27 ~ 2025-02-02가 조회 기준일의 해당 주차인데
여기에 2025-01-31이 포함되므로 2025-01-27 ~ 2025-01-31 / 2025-02-01 ~ 2025-02-02로 찢어서 조회되도록 변경

![[Pasted image 20250219110926.png]]
이런식으로 동적으로 text 박스가 생성되도록 만들어야 했다.

function additionalDate(mondayResult, sundayResult){  
    $("#btnExcelExport").hide();  
    var additionalMonthLastDate = new Date(mondayResult.getFullYear(), mondayResult.getMonth() + 1, 0);  
    var additionalMonthFirstDate = new Date(sundayResult.getFullYear(), sundayResult.getMonth(), 1);  
    $(".common_wrap.clearfix").last().find(".input-group.w450").removeClass("w450").addClass("w400");  
    $(".common_wrap.clearfix:last").after(`  
`<div class="common_wrap clearfix">    <div class="input-group w450">      <input type="text" class="form-control datetimepicker-input" style="height: 35px" id="weekAfterMonday" name="weekAfterMonday"/>      <span class="txt_center" style="margin: auto; font-size: 20px; margin-left: 5px;">~</span>      <input type="text" class="form-control datetimepicker-input" style="height: 35px" id="weekAfterSunday" name="weekAfterSunday"/>      <button id="btnExcelExportNew" name="btnExcelExportNew" type="button" class="btn btn-outline-primary comm-btn openlayer btn_right ml5">엑셀</button>`  
    `</div>  </div>`);  
  return {additionalMonthFirstDate, additionalMonthLastDate};  
  }

일자 계산 시 말일이 포함되는 조건에 부합되면 additionalDate 함수가 실행되어 동적으로 text 박스를 생성하고 엑셀 버튼을 새로 활성화하도록 코드를 구성했다.

일자 계산 후 동적으로 생성되고 해당 날짜 데이터들이 잘 넘어가는것을 확인했다.


# 백엔드 로직 작성

1. 프론트에서 받아온 조회 기준일을 활용하여 쿼리에 사용할 날짜를 생성(개발 중 기준일이 토~금 > 월~일로 변경되었음)
2. 해당 날짜를 활용하여 DB 쿼리 조회
3. 쿼리 결과를 엑셀 양식에 삽입 후 다운로드 데이터 프론트로 전달

  **1.1 날짜 DTO 생성(OverdueBondDateDTO)**
	  @Data  
	@Builder  
	public class OverdueBondDateDTO {  
	    private String week5Sunday;  
	    private String week5Monday;  
	    private String week4Sunday;  
	    private String week4Monday;  
	    private String week3Sunday;  
	    private String week3Monday;  
	    private String week2Sunday;  
	    private String week2Monday;  
	    private String weekSunday;  
	    private String weekMonday;  
	    private String standard1AfterDay;  
	    private String month3First;  
	    private String month3Last;  
	    private String month2First;  
	    private String month2Last;  
	    private String month1First;  
	    private String month1Last;  
	    private String monthFirst;  
	    private String monthLast;  
	    private String month3FirstReal;  
	    private String month2FirstReal;  
	    private String month1FirstReal;  
	    private String monthFirstReal;  
	    private String weekAfterSunday;  
	    private String weekAfterMonday;  
	}
	조회 기준일을 기준으로 5주 전부터 조회 기준일까지의 매주 월~금
	조회 기준일을 기준으로 3달 전부터 조회 기준일이 속한 월까지 매월 초일과 말일
	개발중 추가 된 사항으로 weekAfterSunday와 weekAfterMonday는 프론트 작성에 있던 text 박스가 동적으로 생길 시 추가되는 필드이다.

**1.2 날짜 생성 메서드**
public OverdueBondDateDTO getOverdueBondDateDTO(LocalDate standardDate, Map<String, String> selectDate) {  
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");  
    String week5Monday = standardDate.minusWeeks(4).with(DayOfWeek.MONDAY).format(formatter);  
    String week5Sunday = standardDate.minusWeeks(4).with(DayOfWeek.SUNDAY).format(formatter);  
    String week4Monday = selectDate.get("week4Monday");  
    String week4Sunday = selectDate.get("week4Sunday");  
    String week3Monday = selectDate.get("week3Monday");  
    String week3Sunday = selectDate.get("week3Sunday");  
    String week2Monday = selectDate.get("week2Monday");  
    String week2Sunday = selectDate.get("week2Sunday");  
    String weekMonday = selectDate.get("weekMonday");  
    String weekSunday = selectDate.get("weekSunday");  
    String weekAfterMonday = "";  
    String weekAfterSunday = "";  

    if(selectDate.size() > 9){  
        weekSunday = selectDate.get("weekSunday");  
        weekAfterSunday = selectDate.get("weekAfterSunday");  
        weekAfterMonday = selectDate.get("weekAfterMonday");  
    }  
  
  
    String standard1AfterDay = standardDate.plusDays(1).format(formatter);  
  
    LocalDate month3FirstBefore = standardDate.minusMonths(3).with(TemporalAdjusters.firstDayOfMonth());  
    DayOfWeek dayOfWeek = month3FirstBefore.getDayOfWeek();  
    if (dayOfWeek == DayOfWeek.SATURDAY) {  
        month3FirstBefore = month3FirstBefore.plusDays(2); // 월요일로 이동  
    } else if (dayOfWeek == DayOfWeek.SUNDAY) {  
        month3FirstBefore = month3FirstBefore.plusDays(1); // 월요일로 이동  
    }  
    String month3First = month3FirstBefore.format(formatter);  
    String month3Last = standardDate.minusMonths(3).with(TemporalAdjusters.lastDayOfMonth()).format(formatter);  
  
    LocalDate month2FirstBefore = standardDate.minusMonths(2).with(TemporalAdjusters.firstDayOfMonth());  
    DayOfWeek dayOfWeek2 = month2FirstBefore.getDayOfWeek();  
    if (dayOfWeek2 == DayOfWeek.SATURDAY) {  
        month2FirstBefore = month2FirstBefore.plusDays(2); // 월요일로 이동  
    } else if (dayOfWeek2 == DayOfWeek.SUNDAY) {  
        month2FirstBefore = month2FirstBefore.plusDays(1); // 월요일로 이동  
    }  
    String month2First = month2FirstBefore.format(formatter);  
    String month2Last = standardDate.minusMonths(2).with(TemporalAdjusters.lastDayOfMonth()).format(formatter);  
  
    LocalDate month1FirstBefore = standardDate.minusMonths(1).with(TemporalAdjusters.firstDayOfMonth());  
    DayOfWeek dayOfWeek3 = month1FirstBefore.getDayOfWeek();  
    if (dayOfWeek3 == DayOfWeek.SATURDAY) {  
        month1FirstBefore = month1FirstBefore.plusDays(2); // 월요일로 이동  
    } else if (dayOfWeek3 == DayOfWeek.SUNDAY) {  
        month1FirstBefore = month1FirstBefore.plusDays(1); // 월요일로 이동  
    }  
    String month1First = month1FirstBefore.format(formatter);  
    String month1Last = standardDate.minusMonths(1).with(TemporalAdjusters.lastDayOfMonth()).format(formatter);  
  
    LocalDate monthFirstBefore = standardDate.with(TemporalAdjusters.firstDayOfMonth());  
    DayOfWeek dayOfWeek4 = monthFirstBefore.getDayOfWeek();  
    if (dayOfWeek4 == DayOfWeek.SATURDAY) {  
        monthFirstBefore = monthFirstBefore.plusDays(2); // 월요일로 이동  
    } else if (dayOfWeek4 == DayOfWeek.SUNDAY) {  
        monthFirstBefore = monthFirstBefore.plusDays(1); // 월요일로 이동  
    }  
    String monthFirst = monthFirstBefore.format(formatter);  
    String monthLast = standardDate.with(TemporalAdjusters.lastDayOfMonth()).format(formatter);  
  
    String month3FirstReal = standardDate.minusMonths(3).with(TemporalAdjusters.firstDayOfMonth()).format(formatter);  
    String month2FirstReal = standardDate.minusMonths(2).with(TemporalAdjusters.firstDayOfMonth()).format(formatter);  
    String month1FirstReal = standardDate.minusMonths(1).with(TemporalAdjusters.firstDayOfMonth()).format(formatter);  
    String monthFirstReal = standardDate.with(TemporalAdjusters.firstDayOfMonth()).format(formatter);  
  
    OverdueBondDateDTO overdueBondDateDTO = OverdueBondDateDTO.builder()  
            .week5Sunday(week5Sunday)  
            .week5Monday(week5Monday)  
            .week4Sunday(week4Sunday)  
            .week4Monday(week4Monday)  
            .week3Sunday(week3Sunday)  
            .week3Monday(week3Monday)  
            .week2Sunday(week2Sunday)  
            .week2Monday(week2Monday)  
            .weekSunday(weekSunday)  
            .weekMonday(weekMonday)  
            .standard1AfterDay(standard1AfterDay)  
            .month3First(month3First)  
            .month3Last(month3Last)  
            .month2First(month2First)  
            .month2Last(month2Last)  
            .month1First(month1First)  
            .month1Last(month1Last)  
            .monthFirst(monthFirst)  
            .monthLast(monthLast)  
            .month3FirstReal(month3FirstReal)  
            .month2FirstReal(month2FirstReal)  
            .month1FirstReal(month1FirstReal)  
            .monthFirstReal(monthFirstReal)  
            .weekAfterSunday(weekAfterSunday)  
            .weekAfterMonday(weekAfterMonday)  
            .build();  
  
    return overdueBondDateDTO;  
}

Map<String, String> 타입으로 프론트에서 받아온 날짜 데이터를 week계열의 DTO 필드에 삽입하고
month 계열의 데이터는 조회 기준일인 weekSunday를 기준으로 매월 초일과 말일을 계산하여 DTO 필드에 삽입했다.
또한 월 기준으로 추출하는 데이터들은 월 초일이 주말이면 계좌 거래가 없어서 데이터 산입이 안되기 때문에
해당 주차 바로 다음 월요일로 바꿔서 데이터를 추출해야 한다.

OverdueBondDateDTO에 해당 날짜 데이터들을 삽입하여 DB 쿼리 조회 시 활용

**2.1 Mybatis 쿼리문 작성**
쿼리문을 미리 작성했기 때문에 mybatis에서 큰 문제점은 없었다.
Mapper 클래스에서 dateDto 라는 명칭으로 mybatis에 날짜 데이터들을 넘겨줬고 해당 데이터를 활용하여 쿼리를 실행했다.
다만 문제점은 프론트에서 text 박스가 동적으로 생성되었을 시 쿼리를 변경해줘야하는게 문제였다.
이때는 mybatis에서 지원하는 choose when을 사용하여 쿼리를 분기처리했다.

`<select id="getWeekBalance" resultType="service.framework.statistic.statistic.model.overdueBond.OverdueBondDto">`  
`<choose>`  
    `<when test="dateDto.weekAfterMonday != null and dateDto.weekAfterMonday != ''">`  
        `with settle as (`  
        `SELECT        loan_uid,        sum(settlement_amount) as settlement_amount,        MAX(reg_datetime::date) AS reg_datetime        from resolved_overdue_loan        where reg_datetime between #{dateDto.week4Monday}::date AND #{dateDto.weekAfterSunday}::date + INTERVAL '1 day'        GROUP BY        loan_uid        ORDER BY        loan_uid        )        SELECT        CASE        WHEN slb.base_date between #{dateDto.week4Monday}::date AND #{dateDto.week4Sunday}::date THEN CONCAT(#{dateDto.week4Monday}, ' ~ ', #{dateDto.week4Sunday})        WHEN slb.base_date between #{dateDto.week3Monday}::date AND #{dateDto.week3Sunday}::date THEN CONCAT(#{dateDto.week3Monday}, ' ~ ', #{dateDto.week3Sunday})        WHEN slb.base_date between #{dateDto.week2Monday}::date AND #{dateDto.week2Sunday}::date THEN CONCAT(#{dateDto.week2Monday}, ' ~ ', #{dateDto.week2Sunday})        WHEN slb.base_date between #{dateDto.weekMonday}::date AND #{dateDto.weekSunday}::date THEN CONCAT(#{dateDto.weekMonday}, ' ~ ', #{dateDto.weekSunday})        WHEN slb.base_date between #{dateDto.weekAfterMonday}::date AND #{dateDto.weekAfterSunday}::date THEN CONCAT(#{dateDto.weekAfterMonday}, ' ~ ', #{dateDto.weekAfterSunday})        ELSE '기타'`  
        `END AS date_range,        floor(coalesce(SUM(        CASE        WHEN slb.base_date IN (#{dateDto.week4Monday}::date, #{dateDto.week3Monday}::date, #{dateDto.week2Monday}::date, #{dateDto.weekMonday}::date, #{dateDto.weekAfterMonday}::date)        AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')        THEN slb.balance_amount        ELSE 0        end), 0)/1000        ) AS start_week,        floor(coalesce(SUM(        CASE        WHEN slb.base_date IN (#{dateDto.week4Sunday}::date, #{dateDto.week3Sunday}::date, #{dateDto.week2Sunday}::date, #{dateDto.weekSunday}::date, #{dateDto.weekAfterSunday}::date)        AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')        THEN slb.balance_amount        ELSE 0        end), 0)/1000        ) AS end_week        FROM        stats_loan_balance slb        inner join repayment_state_history rsh        on slb.loan_uid = rsh.loan_uid        and RSH.seq = ( SELECT MAX(seq)        FROM REPAYMENT_STATE_HISTORY        WHERE loan_uid = slb.loan_uid )        left join settle s        on slb.loan_uid = s.loan_uid        WHERE        slb.base_date BETWEEN #{dateDto.week4Monday}::date AND #{dateDto.weekAfterSunday}::date    </when>`  
    `<otherwise>`  
        `with settle as (`  
        `SELECT        loan_uid,        sum(settlement_amount) as settlement_amount,        MAX(reg_datetime::date) AS reg_datetime        from resolved_overdue_loan        where reg_datetime between #{dateDto.week4Monday}::date AND #{dateDto.weekSunday}::date + INTERVAL '1 day'        GROUP BY        loan_uid        ORDER BY        loan_uid        )        SELECT        CASE        WHEN slb.base_date between #{dateDto.week4Monday}::date AND #{dateDto.week4Sunday}::date THEN CONCAT(#{dateDto.week4Monday}, ' ~ ', #{dateDto.week4Sunday})        WHEN slb.base_date between #{dateDto.week3Monday}::date AND #{dateDto.week3Sunday}::date THEN CONCAT(#{dateDto.week3Monday}, ' ~ ', #{dateDto.week3Sunday})        WHEN slb.base_date between #{dateDto.week2Monday}::date AND #{dateDto.week2Sunday}::date THEN CONCAT(#{dateDto.week2Monday}, ' ~ ', #{dateDto.week2Sunday})        WHEN slb.base_date between #{dateDto.weekMonday}::date AND #{dateDto.weekSunday}::date THEN CONCAT(#{dateDto.weekMonday}, ' ~ ', #{dateDto.weekSunday})        ELSE '기타'`  
        `END AS date_range,        floor(coalesce(SUM(        CASE        WHEN slb.base_date IN (#{dateDto.week4Monday}::date, #{dateDto.week3Monday}::date, #{dateDto.week2Monday}::date, #{dateDto.weekMonday}::date)        AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')        THEN slb.balance_amount        ELSE 0        end), 0)/1000        ) AS start_week,        floor(coalesce(SUM(        CASE        WHEN slb.base_date IN (#{dateDto.week4Sunday}::date, #{dateDto.week3Sunday}::date, #{dateDto.week2Sunday}::date, #{dateDto.weekSunday}::date)        AND (slb.repayment_state = 'PRINCIPAL_DELAY' OR slb.repayment_state = 'INTEREST_DELAY')        THEN slb.balance_amount        ELSE 0        end), 0)/1000        ) AS end_week        FROM        stats_loan_balance slb        inner join repayment_state_history rsh        on slb.loan_uid = rsh.loan_uid        and RSH.seq = ( SELECT MAX(seq)        FROM REPAYMENT_STATE_HISTORY        WHERE loan_uid = slb.loan_uid )        left join settle s        on slb.loan_uid = s.loan_uid        WHERE        slb.base_date BETWEEN #{dateDto.week4Monday}::date AND #{dateDto.weekSunday}::date    </otherwise>`  
`</choose>`  
    `GROUP BY`  
        `date_range    ORDER BY        date_range;</select>`

<when test="dateDto.weekAfterMonday != null and dateDto.weekAfterMonday != ''">
weekAfterMonday : text 박스가 동적으로 생성되었을 때 생기는 DTO의 필드
해당 필드가 비어있지 않으면 쿼리에서도 조회되는 일자가 한 줄 추가되도록 구성
그 외에는 원래 만들었던 쿼리로 조회

이렇게 weekAfterMonday를 활용하여 분기처리

그 외 특이한 점은 없음


3.1 조회 데이터 엑셀 삽입

@Override  
public byte[] getOverdueBond(String templateName, Map<String, String> selectDate) {  
    String weekSunday;  
    if(selectDate.size()>9){  
        weekSunday = selectDate.get("weekAfterSunday");  
    } else {  
        weekSunday = selectDate.get("weekSunday");  
    }  
    LocalDate standardDate = LocalDate.parse(weekSunday, DateTimeFormatter.ofPattern("yyyy-MM-dd"));  
  
    OverdueBondDateDTO overdueBondDateDTO = getOverdueBondDateDTO(standardDate, selectDate);  
  
    List<String> monthList = getMonthList(selectDate);  
    List<String> monthOverdue = getMonthOverdue(selectDate);  
  
  
    Map<String, Object> overdueBondExcel = overdueBondMapper.getExcelFile(templateName);  
    byte[] overdueBond = (byte[]) overdueBondExcel.get("template_data");  
  
    if (overdueBond == null) {  
        return null;  
    }  
  
    List<OverdueBondDto> weekBalance = overdueBondMapper.getWeekBalance(overdueBondDateDTO);  
    List<OverdueBondDto> weekBalanceNew = overdueBondMapper.getWeekBalanceNew(overdueBondDateDTO);  
    List<OverdueBondDto> weekAccount = overdueBondMapper.getWeekAccount(overdueBondDateDTO);  
    List<OverdueBondDto> monthTotalBalance = overdueBondMapper.getMonthTotalBalance(overdueBondDateDTO);  
    List<OverdueBondDto> monthRepayment = overdueBondMapper.getMonthRepayment(overdueBondDateDTO);  
    List<OverdueBondDto> monthNewOverdue = overdueBondMapper.getMonthNewOverdue(overdueBondDateDTO);  
    List<OverdueBondDto> distribution = overdueBondMapper.getDistribution(overdueBondDateDTO);  
    List<OverdueBondDto> selfRepayment = overdueBondMapper.getSelfRepayment(overdueBondDateDTO);  
    List<OverdueBondDto> expectationOverdue = overdueBondMapper.getExpectationOverdue(overdueBondDateDTO);  
  
    //쿼리 조회결과 excel에 주입 후 리턴  
    try (InputStream is = new ByteArrayInputStream(overdueBond);  
         Workbook workbook = WorkbookFactory.create(is);  
         ByteArrayOutputStream baos = new ByteArrayOutputStream()) {  
  
        Sheet sheet = workbook.getSheetAt(0);  
  
        /*2. 연체해결 상세내역 및 신규연체 상세내역 해당 월 String 할당*/  
        int rowCount = 23;  
            Row standardRow = sheet.getRow(rowCount);  
            standardRow.getCell(1).setCellValue(monthOverdue.get(0));  
            standardRow.getCell(3).setCellValue(monthOverdue.get(1));  
            standardRow.getCell(5).setCellValue(monthOverdue.get(2));  
            rowCount = 30;  
            Row newOverdueRow = sheet.getRow(rowCount);  
            newOverdueRow.getCell(0).setCellValue(monthOverdue.get(3));  
  
        /* 1. 연체잔액 증감표(시작, 마감) */  
        rowCount = 2;  
  
        for (OverdueBondDto data : weekBalance) {  
            Row row = sheet.getRow(rowCount++);  
  
           row.getCell(0).setCellValue(data.getDateRange());  
           row.getCell(1).setCellValue(data.getStartWeek());  
           row.getCell(4).setCellValue(data.getEndWeek());  
        }  
  
        /* 1. 연체잔액 증감표(신규, 해소) */  
        rowCount = 2;  
        for (OverdueBondDto data : weekBalanceNew) {  
            Row row = sheet.getRow(rowCount++);  
  
            row.getCell(2).setCellValue(data.getNewOverdueWeek());  
            row.getCell(3).setCellValue(data.getOutOverdueWeek());  
        }  
  
        /* 1. 연체잔액 증감표 오른쪽 부분 */        rowCount = 2;  
        for (int i = 1; i<weekAccount.size(); i++) {  
            Row row = sheet.getRow(rowCount++);  
            // 데이터 삽입 (예: 첫 번째 열에 데이터)  
            row.getCell(6).setCellValue(weekAccount.get(i).getAccountCount());  
            row.getCell(7).setCellValue(weekAccount.get(i).getAccountCountVariation());  
            row.getCell(8).setCellValue(weekAccount.get(i).getBalance());  
            row.getCell(9).setCellValue(weekAccount.get(i).getBalanceVariation());  
        }  
  
        /*연체 잔액 예상표 월 구분 String 할당*/  
        rowCount = 8;  
        for(int i = 0; i < monthList.size(); i++){  
            Row row = sheet.getRow(rowCount);  
  
            int cellIndex = 1+i;  
            if(cellIndex > 9) break;  
  
            Cell cell = row.getCell(cellIndex);  
            cell.setCellValue(monthList.get(i));  
        }  
  
        /*월시작 ~ 장기연체*/  
        rowCount = 9;  
        int firstCellIndex = 1;  
  
        for (int i = 0; i < monthTotalBalance.size(); i++) {  
            OverdueBondDto data = monthTotalBalance.get(i);  
  
            int columnIndex = firstCellIndex + i;  
  
            Row row1 = sheet.getRow(rowCount);  
            Cell cell1 = row1.getCell(columnIndex);  
            cell1.setCellValue(data.getStartMonth());  
  
            Row row2 = sheet.getRow(rowCount + 1);  
            Cell cell2 = row2.getCell(columnIndex);  
            cell2.setCellValue(data.getLongOverdue());  
        }  
  
        /*연체해결합계 ~ 장기연체해소, 기준 월 매각 완료 및 예상*/  
        rowCount = 12;  
  
        for (int i = 0; i < monthRepayment.size(); i++) {  
            OverdueBondDto data = monthRepayment.get(i);  
  
            int columnIndex = firstCellIndex + i;  
  
            Row row1 = sheet.getRow(rowCount);  
            Cell cell1 = row1.getCell(columnIndex);  
            cell1.setCellValue(data.getOutOverdueMonth());  
  
            Row row2 = sheet.getRow(rowCount + 2);  
            Cell cell2 = row2.getCell(columnIndex);  
            cell2.setCellValue(data.getSaleRepayment());  
  
            if(i==monthRepayment.size()-1){  
                Row row4 = sheet.getRow(rowCount + 14);  
                row4.getCell(3).setCellValue(data.getOutSaleRepaymentCount());  
                row4.getCell(4).setCellValue(data.getOutSaleRepaymentSum());  
                row4.getCell(5).setCellValue(data.getOutSaleRepaymentCountExpectation());  
                row4.getCell(6).setCellValue(data.getOutSaleRepaymentSumExpectation());  
            }  
        }  
  
  
        /*해당월 자력상환 if 분기*/  
        int selfRepaymentSum = 0;  
        for(int i = 0; i < monthRepayment.size()-1; i++){  
            OverdueBondDto repayment = monthRepayment.get(i);  
            OverdueBondDto distributionList = distribution.get(i);  
            selfRepaymentSum += repayment.getOutOverdueMonth() - distributionList.getDistribution() - repayment.getSaleRepayment();  
        }  
  
        int selfRepaymentResult = selfRepaymentSum/3;  
        if(selfRepayment.get(0).getSelfRepaymentSum() > selfRepaymentResult){  
            Row row = sheet.getRow(15);  
            row.getCell(4).setCellValue(selfRepayment.get(0).getSelfRepaymentSum());  
        } else {  
            Row row = sheet.getRow(15);  
            row.getCell(4).setCellValue(selfRepaymentResult);  
        }  
  
        /*신규발생 연체 ~ 이자지연*/  
        rowCount = 16;  
  
        for (int i = 0; i < monthNewOverdue.size(); i++) {  
            OverdueBondDto data = monthNewOverdue.get(i);  
  
            int columnIndex = firstCellIndex + i;  
  
            Row row1 = sheet.getRow(rowCount);  
            Cell cell1 = row1.getCell(columnIndex);  
            cell1.setCellValue(data.getTotalNewOverdue());  
  
            Row row2 = sheet.getRow(rowCount + 1);  
            Cell cell2 = row2.getCell(columnIndex);  
            cell2.setCellValue(data.getPrincipalLoanAmount());  
  
            Row row3 = sheet.getRow(rowCount + 2);  
            Cell cell3 = row3.getCell(columnIndex);  
            cell3.setCellValue(data.getInterestLoanAmount());  
        }  
  
        rowCount = 19;  
        /*월말예상*/  
        for(int i = 0; i<3; i++){  
            int columnIndex = firstCellIndex + i;  
            int monthLastExpectation;  
  
            monthLastExpectation = monthTotalBalance.get(i).getStartMonth() - monthRepayment.get(i).getOutOverdueMonth() +  
            monthNewOverdue.get(i).getTotalNewOverdue() - monthRepayment.get(i).getLongOverdueRepayment();  
  
            Row row = sheet.getRow(rowCount);  
            Cell cell = row.getCell(columnIndex);  
            cell.setCellValue(monthLastExpectation);  
        }  
  
        /*배당 상환, 기준 월 배당 상환 완료 및 예상*/  
        rowCount = 13;  
  
        for (int i = 0; i < distribution.size(); i++) {  
            OverdueBondDto data = distribution.get(i);  
  
            int columnIndex = firstCellIndex + i;  
  
            Row row1 = sheet.getRow(rowCount);  
            Cell cell1 = row1.getCell(columnIndex);  
            cell1.setCellValue(data.getDistribution());  
  
            if(i==monthRepayment.size()-1){  
                Row row4 = sheet.getRow(rowCount + 12);  
                row4.getCell(3).setCellValue(data.getOutDistributionCount());  
                row4.getCell(4).setCellValue(data.getOutDistributionSum());  
                row4.getCell(5).setCellValue(data.getDistributionCountExpectation());  
                row4.getCell(6).setCellValue(data.getDistributionSumExpectation());  
            }  
        }  
  
        /*자력해결완료*/  
        rowCount = 27;  
        for(int i = 0; i<selfRepayment.size(); i++){  
            OverdueBondDto data = selfRepayment.get(i);  
            Row row = sheet.getRow(rowCount);  
            row.getCell(3).setCellValue(data.getSelfRepaymentCount());  
            row.getCell(4).setCellValue(data.getSelfRepaymentSum());  
        }  
  
        /*신규 연체 발생 종류별*/  
        rowCount = 32;  
        for(int i = 0; i<expectationOverdue.size(); i++){  
            OverdueBondDto data = expectationOverdue.get(i);  
  
            Row row = sheet.getRow(rowCount);  
            row.getCell(3).setCellValue(data.getInterestNormalCount());  
            row.getCell(4).setCellValue(data.getInterestNormalSum());  
            row.getCell(5).setCellValue(data.getInterestAddCount());  
            row.getCell(6).setCellValue(data.getInterestAddSum());  
            row.getCell(7).setCellValue(data.getInterestExtendCount());  
            row.getCell(8).setCellValue(data.getInterestExtendSum());  
  
            Row row2 = sheet.getRow(rowCount+1);  
            row2.getCell(3).setCellValue(data.getPrincipalNormalCount());  
            row2.getCell(4).setCellValue(data.getPrincipalNormalSum());  
            row2.getCell(5).setCellValue(data.getPrincipalAddCount());  
            row2.getCell(6).setCellValue(data.getPrincipalAddSum());  
            row2.getCell(7).setCellValue(data.getPrincipalExtendCount());  
            row2.getCell(8).setCellValue(data.getPrincipalExtendSum());  
        }  
  
  
        FormulaEvaluator evaluator = workbook.getCreationHelper().createFormulaEvaluator();  
        evaluator.evaluateAll();  
        workbook.write(baos);  
  
        return baos.toByteArray(); // 수정된 Excel 파일 반환  
    } catch (IOException | InvalidFormatException e) {  
        throw new RuntimeException("엑셀 파일 생성 중 오류가 발생했습니다.", e);  
    }  
}


조회 데이터를 엑셀 양식에 맞게 해당 셀에 삽입